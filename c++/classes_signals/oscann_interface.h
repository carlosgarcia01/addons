/*
 * This file was generated by qdbusxml2cpp version 0.8
 * Command line was: qdbusxml2cpp -p oscann_interface.h: ../../OAOI/dbus/oscann.xml
 *
 * qdbusxml2cpp is Copyright (C) 2015 The Qt Company Ltd.
 *
 * This is an auto-generated file.
 * Do not edit! All changes made to it will be lost.
 */

#ifndef OSCANN_INTERFACE_H
#define OSCANN_INTERFACE_H

#include <QtCore/QObject>
#include <QtCore/QByteArray>
#include <QtCore/QList>
#include <QtCore/QMap>
#include <QtCore/QString>
#include <QtCore/QStringList>
#include <QtCore/QVariant>
#include <QtDBus/QtDBus>

/*
 * Proxy class for interface aura.CVInterface
 */
class AuraCVInterfaceInterface: public QDBusAbstractInterface
{
    Q_OBJECT
public:
    static inline const char *staticInterfaceName()
    { return "aura.CVInterface"; }

public:
    AuraCVInterfaceInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);

    ~AuraCVInterfaceInterface();

public Q_SLOTS: // METHODS
Q_SIGNALS: // SIGNALS
    void changeSettingsDBus(int value, int id);
    void displayImagesDbus(bool value);
};

/*
 * Proxy class for interface aura.CapturerInterface
 */
class AuraCapturerInterfaceInterface: public QDBusAbstractInterface
{
    Q_OBJECT
public:
    static inline const char *staticInterfaceName()
    { return "aura.CapturerInterface"; }

public:
    AuraCapturerInterfaceInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);

    ~AuraCapturerInterfaceInterface();

public Q_SLOTS: // METHODS
Q_SIGNALS: // SIGNALS
    void newControlAddedDBus(const QString &ctrlName, int ctrlID, int ctrlMinValue, int ctrlMaxValue, int ctrlValue);
    void newValidationImgDBus(bool logo);
    void saveImageDbus(const QString &timestamp, uint msgTo);
    void signalTest();
    void statusChangedDBus(int cameraType, int width, int height, int fps);
    void updateImageDBus(int x, int y, int width, int height);
};

/*
 * Proxy class for interface aura.DetectorInterface
 */
class AuraDetectorInterfaceInterface: public QDBusAbstractInterface
{
    Q_OBJECT
public:
    static inline const char *staticInterfaceName()
    { return "aura.DetectorInterface"; }

public:
    AuraDetectorInterfaceInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);

    ~AuraDetectorInterfaceInterface();

public Q_SLOTS: // METHODS
Q_SIGNALS: // SIGNALS
    void loadingDBus(double percent);
    void progressDBus(double percent, double totalPercent);
    void pupilAtDBus(double x, double y, double sx, double sy);
    void ready();
};

/*
 * Proxy class for interface aura.DisplayCTInterface
 */
class AuraDisplayCTInterfaceInterface: public QDBusAbstractInterface
{
    Q_OBJECT
public:
    static inline const char *staticInterfaceName()
    { return "aura.DisplayCTInterface"; }

public:
    AuraDisplayCTInterfaceInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);

    ~AuraDisplayCTInterfaceInterface();

public Q_SLOTS: // METHODS
Q_SIGNALS: // SIGNALS
    void closeVideoDbus();
    void deleteFilesDbus();
    void finishDemoDbus();
    void onCalibrationDBus(bool value);
    void saveImagesDbus(bool value);
    void scatterDBus(uint index);
    void stimuliOnViewerDBus(bool flag);
    void stimulus2SaveDbus(int x, int y);
    void testDurationDBus(uint time);
    void validateDBus();
};

/*
 * Proxy class for interface aura.GUIInterface
 */
class AuraGUIInterfaceInterface: public QDBusAbstractInterface
{
    Q_OBJECT
public:
    static inline const char *staticInterfaceName()
    { return "aura.GUIInterface"; }

public:
    AuraGUIInterfaceInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);

    ~AuraGUIInterfaceInterface();

public Q_SLOTS: // METHODS
    inline QDBusPendingReply<> methodName()
    {
        QList<QVariant> argumentList;
        return asyncCallWithArgumentList(QStringLiteral("methodName"), argumentList);
    }

Q_SIGNALS: // SIGNALS
    void config(int rmin, int rmax, double cannyBlur, double cannyThld1, double cannyThld2, int StarburstPoints, bool online);
    void configDbus(int task, int numberOfPoints, double sDist, double sWidth, int resolutionX, int resolutionY, int stimulusSize, int clb, int tst, int variant, int time, int laps, int frequency, const QString &imgName, const QString &directoryName, bool fromRun);
    void configTrackerDBus(int width, int height);
    void frequencyDbus(int value);
    void keyPressedDbus(int key);
    void lapsDbus(int value);
    void newD1FileDBus(const QString &dataFile);
    void newSettingsDBus(const QString &directory, const QString &dataFile, bool isTst, const QString &codec);
    void normalStateDbus();
    void processDBus(const QString &directory, int freq, int width, int height, uint totalFramesToProcess);
    void saveImagesDbus(bool value);
    void sharedMemoryDbus();
    void showStimulus();
    void shutdownDBus(uint type);
    void stopDBus();
};

/*
 * Proxy class for interface aura.WriterInterface
 */
class AuraWriterInterfaceInterface: public QDBusAbstractInterface
{
    Q_OBJECT
public:
    static inline const char *staticInterfaceName()
    { return "aura.WriterInterface"; }

public:
    AuraWriterInterfaceInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);

    ~AuraWriterInterfaceInterface();

public Q_SLOTS: // METHODS
Q_SIGNALS: // SIGNALS
    void nextTestDbus();
};

namespace aura {
  typedef ::AuraCVInterfaceInterface CVInterface;
  typedef ::AuraCapturerInterfaceInterface CapturerInterface;
  typedef ::AuraDetectorInterfaceInterface DetectorInterface;
  typedef ::AuraDisplayCTInterfaceInterface DisplayCTInterface;
  typedef ::AuraGUIInterfaceInterface GUIInterface;
  typedef ::AuraWriterInterfaceInterface WriterInterface;
}
#endif
